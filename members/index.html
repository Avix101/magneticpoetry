<!DOCTYPE html>
<html lang="en">
<head>
	<title>Magnetic Poetry</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="/style.css">
	
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Berkshire+Swash|Gloria+Hallelujah|Indie+Flower|Kaushan+Script|Nanum+Pen+Script|Pacifico|Permanent+Marker|Tangerine" rel="stylesheet">
	
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
    <script type="text/babel" >
        "use strict";
    
		let canvas, ctx, socket, selectedTool, toolActive, audioCtx, owner, name;
		
		let bgImage;
		
		let draggingWordIndex;
		let dragging = false;
		let prevMousePos = {};
		
		let words = [];
		let wordsToEdit = [];
		const wordIndexer = {};
		
		let newWord = {
			content: "",
			owner,
			created: new Date().getTime(),
			bgColor: "#ADD8E6",
			textColor: "#000000",
			font: "Arial",
			fontSize: 32,
			x: 0,
			y: 0,
			width: 0,
			deployed: false,
		}
		
		const selectBox = {
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0,
		};
		
		const defaultWords = ["ashen", "knight", "verdant", "city", "starless", "sky", "endless", "abyss",
		"ancient", "quarry", "to", "be", "am", "I", "who", "is", "when", "the", "time", "cannot", "can", "will",
		"won't", "are", "aren't", "then", "those", "this", "that", "them", "a", "in", "we", "an", "meme", "lord"];
		
		const redrawCanvas = () => {
			requestAnimationFrame(redrawCanvas);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			if(bgImage){
				ctx.drawImage(bgImage, 0, 0, 800, 800);
			}
			
			const localZoneLineHeight = (canvas.height / 4) * 3;
			
			ctx.fillStyle = "black";
			ctx.globalAlpha = 0.4;
			ctx.fillRect(0, localZoneLineHeight, canvas.width, canvas.height);
			ctx.globalAlpha = 1;
			
			//Draw local zone line
			ctx.save();
			ctx.setLineDash([4, 3]);
			ctx.lineDashOffset = -(new Date().getTime() * 0.01) % 7;
			ctx.beginPath();
			ctx.moveTo(0, localZoneLineHeight);
			ctx.lineTo(canvas.width, localZoneLineHeight);
			ctx.stroke();
			ctx.restore();
			
			const time = new Date().getTime();
			
			for(let i = 0; i < words.length; i++){
				const word = words[i];
				
				drawWord(word, 1);
				const rect = {x: word.x - 5, y: word.y - 5, width: word.width + 10, height: word.fontSize + 8};
				
				if(word.owner === owner){
					switch(selectedTool){
						case "wordTool":
							drawSelectBox("blue", "blue", time, 0.01, rect);
							break;
						case "editTool":
							drawSelectBox("yellow", "yellow", time, 0.01, rect);
							break;
						case "deleteTool":
							drawSelectBox("red", "red", time, 0.01, rect);
							break;
					}
				}
			}
			
			switch(selectedTool){
				case "playbackSelect":
					drawSelectBox("green", "lime", time, 0.02);
					break;
				case "addTool":
					drawWord(newWord, 0.5);
					break;
				case "editTool":
					drawSelectBox("orange", "orange", time, 0.02); 
				case "deleteTool":
					drawSelectBox("red", "red", time, 0.03);
					break;
			}
		};
		
		const drawWord = (word, opacity) => {
		
			ctx.save();
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.strokeStyle = "grey";
			ctx.lineWidth = 2;
			ctx.globalAlpha = opacity;
		
			const rect = {x: word.x - 5, y: word.y - 5, width: word.width + 10, height: word.fontSize + 8};
			ctx.fillStyle = word.bgColor;
			ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
			ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
			
			ctx.font = `${word.fontSize}px ${word.font}`;
			ctx.fillStyle = word.textColor;
			ctx.fillText(word.content, word.x + (word.width / 2), word.y + word.fontSize / 2);
			
			ctx.restore();
		};
		
		const sendWordUpdate = (word) => {
			socket.emit('wordUpdate', {word});
		};
		
		const sendDeleteRequest = (word) => {
			socket.emit('deleteWord', {word});
		};
		
		const checkWordSpace = (word) => {
			const localZoneLineHeight = (canvas.height / 4) * 3;
			
			if(word.y + word.fontSize + 8 < localZoneLineHeight){
				word.deployed = true;
				sendWordUpdate(word);
			} else {
				if(word.deployed){
					word.deployed = false;
					sendDeleteRequest(word);
				}
			}
		};
		
		const activateTool = (e) => {
			switch(selectedTool){
				case "playbackSelect":
					startSelectBox(e);
					break;
				case "wordTool":
					pickupWord(e);
					break;
				case "addTool":
					placeNewWord(e);
					break;
				case "editTool":
					startSelectBox(e);
					break;
				case "deleteTool":
					startSelectBox(e);
					break;
			}
			
			toolActive = true;
		};
		
		const moveTool = (e) => {
		
			if(!toolActive && selectedTool != "addTool"){
				return;
			}
		
			switch(selectedTool){
				case "playbackSelect":
					updateSelectBox(e);
					break;
				case "addTool":
					updateNewWord(e);
					break;
				case "wordTool":
					dragWord(e);
					break;
				case "editTool":
					updateSelectBox(e);
					break;
				case "deleteTool":
					updateSelectBox(e);
					break;
			}
		};
		
		const stopTool = (e) => {
		
			if(!toolActive){
				return;
			}
		
			switch(selectedTool){
				case "playbackSelect":
					updateSelectBox(e);
					parseSelection(arrangeWords);
					break;
				case "wordTool":
					dropWord(e);
					break;
				case "editTool":
					updateSelectBox(e);
					parseSelection(editSelection);
					break;
				case "deleteTool":
					updateSelectBox(e);
					parseSelection(deleteSelection);
					break;
			}
			
			toolActive = false;
		};
		
		const changeTool = (e, tool) => {
			selectedTool = tool;
			
			selectBox.x1 = 0;
			selectBox.x2 = 0;
			selectBox.y1 = 0;
			selectBox.y2 = 0;
			
			const wordContentField = document.querySelector("#wordContent");
			wordContentField.disabled = selectedTool === "editTool";
			
			const marker = document.querySelector("#selectedToolMarker");
			marker.remove();
			
			const toolPara = e.currentTarget.parentElement;
			toolPara.appendChild(marker);
		};
		
		const startSelectBox = (e) => {
			const mouse = getMousePosition(e);
			selectBox.x1 = mouse.x;
			selectBox.x2 = mouse.x;
			selectBox.y1 = mouse.y;
			selectBox.y2 = mouse.y;
		};
		
		const updateSelectBox = (e) => {
			const mouse = getMousePosition(e);
			selectBox.x2 = mouse.x;
			selectBox.y2 = mouse.y;
		};
		
		const updateNewWord = (e) => {
			console.log(newWord);
			const mouse = getMousePosition(e);
			newWord.x = mouse.x;
			newWord.y = mouse.y;
		};
		
		const placeNewWord = (e) => {
			newWord.owner = owner;
			newWord.created = new Date().getTime();
			const key = `${newWord.owner}${newWord.content}${newWord.created}`;
			const index = words.length;
			words.push(newWord);
			wordIndexer[key] = index;
			
			checkWordSpace(words[index]);
			
			newWord = {
				content: newWord.content,
				owner,
				created: new Date().getTime(),
				bgColor: newWord.bgColor,
				textColor: newWord.textColor,
				font: newWord.font,
				fontSize: newWord.fontSize,
				x: newWord.x,
				y: newWord.y,
				width: newWord.width,
				deployed: false,
			};
		};
		
		const drawSelectBox = (outerColor, innerColor, timeSeed, speed, rect) => {
			ctx.save();
			ctx.setLineDash([4, 3]);
			ctx.lineDashOffset = -(timeSeed * speed) % 7;
			ctx.strokeStyle = outerColor;
			ctx.fillStyle = innerColor;
			ctx.globalAlpha = 0.3;
			
			if(rect !== undefined){
				ctx.lineWidth = 3;
				ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
			} else {
				const width = selectBox.x2 - selectBox.x1;
				const height = selectBox.y2 - selectBox.y1;
			
				ctx.fillRect(selectBox.x1, selectBox.y1, width, height);
				ctx.strokeRect(selectBox.x1, selectBox.y1, width, height);
			}
			
			ctx.restore();
		};
		
		const pickupWord = (e) => {
			const mouse = getMousePosition(e);
			
			for(let i = 0; i < words.length; i++){
				const word = words[i];
				
				if(mouse.x > word.x - 5 && mouse.x < word.x + word.width + 10){
					if(mouse.y > word.y - 5 && mouse.y < word.y + word.fontSize + 8 && word.owner === owner){
						prevMousePos = mouse;
						dragging = true;
						draggingWordIndex = i;
						return;
					}
				}
			};
		};
		
		const dragWord = (e) => {
			if(!dragging){
				return;
			}
			
			const mouse = getMousePosition(e);
			const deltaX = mouse.x - prevMousePos.x;
			const deltaY = mouse.y - prevMousePos.y;
			prevMousePos = mouse;
			
			words[draggingWordIndex].x += deltaX;
			words[draggingWordIndex].y += deltaY;
			
			checkWordSpace(words[draggingWordIndex]);
		};
		
		const dropWord = (e) => {
		
			if(!dragging){
				return;
			}
			
			checkWordSpace(words[draggingWordIndex]);
			dragging = false;
			draggingWordIndex = -1;
		};
		
		//Taken from https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas
		const getMousePosition = (e) => {
			const rect = canvas.getBoundingClientRect();
			return {
				x: e.clientX - rect.left,
				y: e.clientY - rect.top,
			};
		};
		
		const parseSelection = (callback) => {
			let selectedWords = [];
			
			for(let i = 0; i < words.length; i++){
				const word = words[i];
				
				const leftX = selectBox.x1 < selectBox.x2 ? selectBox.x1 : selectBox.x2;
				const topY = selectBox.y1 < selectBox.y2 ? selectBox.y1 : selectBox.y2;
				const width = Math.abs(selectBox.x2 - selectBox.x1);
				const height = Math.abs(selectBox.y2 - selectBox.y1);
				
				if(word.x - 5 > leftX + width || word.x + word.width + 5 < leftX){
					continue;
				}
				
				if(word.y - 5 > topY + height || word.y - 5 + word.fontSize + 8 < topY){
					continue;
				}
				
				selectedWords.push(word);
			}
			
			callback(selectedWords);
		};
		
		const arrangeWords = (selectedWords) => {
		
			//Arrange words in order on x axis first
			selectedWords.sort((a, b) => {
				return a.x - b.x;
			});
			
			const rows = [];
			
			for(let i = 0; i < selectedWords.length; i++){
				const word = selectedWords[i];
				
				if(!appendRow(word, rows)){
					const row = {
						upper: word.y + (word.fontSize * 3) / 4,
						lower: word.y - (word.fontSize * 3) / 4,
						words: []
					};
					
					row.words.push(word);
					rows.push(row);
				}
			}
			
			rows.sort((a, b) => {
				return a.lower - b.lower;
			});
			
			processSelection(rows);
		};
		
		const editSelection = (selectedWords) => {
			wordsToEdit = selectedWords;
			
			const wordContentField = document.querySelector("#wordContent");
			
			if(wordsToEdit.length == 1){
				const word = wordsToEdit[0];
				
				if(word.owner !== owner){
					return;
				}
				
				const bgColorField = document.querySelector("#bgColorSelect");
				const textColorField = document.querySelector("#textColorSelect");
				const fontField = document.querySelector("#fontSelect");
				const fontSizeField = document.querySelector("#fontSizeSelect");
				
				wordContentField.value = word.content;
				bgColorField.value = word.bgColor;
				textColorField.value = word.textColor;
				
				fontField.value = word.font;
				fontSizeField.value = word.fontSize;
			} else {
				wordContentField.value = "";
			}
		};
		
		const onWordDetailUpdate = (e) => {
		
			const wordContentField = document.querySelector("#wordContent");
			const bgColorField = document.querySelector("#bgColorSelect");
			const textColorField = document.querySelector("#textColorSelect");
			const fontField = document.querySelector("#fontSelect");
			const fontSizeField = document.querySelector("#fontSizeSelect");
			
			if(selectedTool === "editTool"){
				for(let i = 0; i < wordsToEdit.length; i++){
					const word = wordsToEdit[i];
					
					if(word.owner !== owner){
						continue;
					}
					
					word.bgColor = bgColorField.value;
					word.textColor = textColorField.value;
					word.font = fontField.options[fontField.selectedIndex].value;
					word.fontSize = parseInt(fontSizeField.options[fontSizeField.selectedIndex].value);
					
					ctx.save();
					ctx.font = `${word.fontSize}px ${word.font}`;
					word.width = ctx.measureText(word.content).width;
					ctx.restore();
					
					checkWordSpace(word);
				}
			}
			
			newWord.content = wordContentField.value;
			newWord.bgColor = bgColorField.value;
			newWord.textColor = textColorField.value;
			newWord.font = fontField.options[fontField.selectedIndex].value;
			newWord.fontSize = parseInt(fontSizeField.options[fontSizeField.selectedIndex].value);
			newWord.width = ctx.measureText(newWord.content).width;
		};
		
		const deleteSelection = (selectedWords) => {
			for(let i = 0; i < selectedWords.length; i++){
				const word = selectedWords[i];
				if(word.deployed){
					sendDeleteRequest(word);
					word.deployed = false;
				}
				
				if(owner === word.owner){
					word.x = -5000;
					word.y = -5000;
				}
			}
		};
		
		//Helper function for parsing word selections
		const appendRow = (word, rows) => {
			for(let j = 0; j < rows.length; j++){
				const row = rows[j];
				if(word.y <= row.upper && word.y >= row.lower){
					row.words.push(word);
					return true;
				}
			}
			return false;
		};
		
		const processSelection = (rows) => {
			let ttsString = "<speak>";
			
			if(rows.length === 0){
				return;
			}
			
			for(let i = 0; i < rows.length; i++){
				const row = rows[i];
				let prevX;
				
				for(let j = 0; j < row.words.length; j++){
					const word = row.words[j];
					
					if(prevX && prevX < word.x - 50){
					//Break horizontal gaps
						ttsString = `${ttsString}, <break strength="strong"/>`;
					}
					
					ttsString = `${ttsString} ${word.content}`;
					prevX = word.x + word.width + 10;
				}
				//Break rows
				ttsString = `${ttsString} <break strength="x-strong"/>\n`;
			}
			
			ttsString = `${ttsString}</speak>`;
			
			requestTTS(ttsString);
		};
		
		//Learned how to process tts using Amazon Polly from:
		//https://medium.com/@smcelhinney/building-a-greeting-app-using-amazon-polly-and-nodejs-a605f29c20f5
		const processTTS = (data) => {
			const source = audioCtx.createBufferSource();
			audioCtx.decodeAudioData(data, (buffer) => {
				source.buffer = buffer;
				source.connect(audioCtx.destination);
				source.start(audioCtx.currentTime);
			});
		};
		
		const requestTTS = (ttsString) => {
			const xhr = new XMLHttpRequest();
			xhr.open('POST', '/request-tts', true);
			xhr.responseType = 'arraybuffer';
			
			xhr.onload = () => {
				const data = xhr.response;
				processTTS(data);
			};
			
			xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
			
			xhr.send(JSON.stringify({text: ttsString}));
		};
		
		const sendMessage = () => {
			const messageBox = document.querySelector("#chatText");
			const message = messageBox.value;
			
			if(message === ""){
				return;
			}
			
			messageBox.value = "";
			socket.emit('chatMessage', {name, message});
		};
		
		const buildWordBank = (wordSet) => {
			
			const localZoneLineHeight = (canvas.height / 4) * 3;
			let x = 10;
			let y = localZoneLineHeight + 10;
			
			for(let i = 0; i < wordSet.length; i++){
			
				ctx.font = "32px Nanum Pen Script";
				let width = ctx.measureText(wordSet[i]).width;
				
				if(x + width + 20 > canvas.width){
					y += 50;
					x = 10;
				} 
			
				const word = {
					content: wordSet[i],
					owner,
					created: new Date().getTime(),
					bgColor: "#ADD8E6",
					textColor: "#000000",
					font: "Nanum Pen Script",
					fontSize: 32,
					x,
					y,
					width,
					deployed: false,
				}
				
				const key = `${word.owner}${word.content}${word.created}`;
				const index = words.length;
				words.push(word);
				wordIndexer[key] = index;
				
				x += width + 20;
			}
		};
		
		const attachSocketEvents = (sock) => {
			sock.on('wordUpdate', (data) => {
				const key = `${data.word.owner}${data.word.content}${data.word.created}`;
				
				if(wordIndexer[key] !== undefined && wordIndexer[key].deleted){
					if(wordIndexer[key].lastUpdate >= data.word.lastUpdate){
						return;
					} else {
						wordIndexer[key] = wordIndexer[key].index;
					}
				}
				
				if(wordIndexer[key] !== undefined){
				
					const index = wordIndexer[key];
					
					if(words[index].lastUpdate >= data.word.lastUpdate){
						return;
					}
					
					words[index].x = data.word.x;
					words[index].y = data.word.y;
					words[index].created = data.word.created;
					words[index].bgColor = data.word.bgColor;
					words[index].textColor = data.word.textColor;
					words[index].font = data.word.font;
					words[index].fontSize = data.word.fontSize;
					words[index].lastUpdate = data.word.lastUpdate;
					words[index].deployed = true;
					
					ctx.save();
					ctx.font = `${data.word.fontSize}px ${data.word.font}`;
					words[index].width = ctx.measureText(words[index].content).width;
					ctx.restore();
					
				} else {
					const index = words.length;
					
					words.push(data.word);
					wordIndexer[key] = index;
				}
			});
			
			sock.on('deleteWord', (data) => {
				const key = `${data.word.owner}${data.word.content}${data.word.created}`;
				if(wordIndexer[key] !== undefined){
					const index = wordIndexer[key];
					
					//Move the word offscreen, remap the index if the word reappears
					words[index].x = -5000;
					
					wordIndexer[key] = {deleted: true, lastUpdate: data.word.lastUpdate, index: index};
				}
			});
			
			sock.on('credentials', (data) => {
				owner = data.id;
				name = data.username;
			});
			
			sock.on('wordbank', (data) => {
				if(data){
					buildWordBank(data);
				} else {
					buildWordBank(defaultWords);
				}
			});
			
			sock.on('chatMessage', (data) => {
				
				const chatWindow = document.querySelector("#chatRoom");
				
				const para = document.createElement('p');
				const messageElement = document.createElement('span');
				const nameElement = document.createElement('span');
				
				nameElement.textContent = `${data.name}: `;
				nameElement.classList.add('bold-text');
				
				messageElement.textContent += `${data.message}`;
				
				para.appendChild(nameElement);
				para.appendChild(messageElement);
				
				chatWindow.appendChild(para);
			});
		};
		
		const init = () => {
			socket = io.connect();
			attachSocketEvents(socket);
			
			window.AudioContext = window.AudioContext || window.webkitAudioContext;
			audioCtx = new AudioContext();
			
			selectedTool = "wordTool";
			
			canvas = document.querySelector("#viewport");
			canvas.addEventListener('mousedown', activateTool);
			canvas.addEventListener('mousemove', moveTool);
			canvas.addEventListener('mouseout', stopTool);
			canvas.addEventListener('mouseup', stopTool);
			
			const sendChatButton = document.querySelector("#sendMessage");
			sendChatButton.addEventListener('click', sendMessage);
			
			const playbackToolSelect = document.querySelector("#playbackTool");
			const addTool = document.querySelector("#addWordTool");
			const wordTool = document.querySelector("#wordTool");
			const editTool = document.querySelector("#editWordTool");
			const deleteTool = document.querySelector("#deleteWordTool");
			
			playbackToolSelect.addEventListener('click', (e) => changeTool(e, "playbackSelect"));
			addTool.addEventListener('click', (e) => changeTool(e, "addTool"));
			wordTool.addEventListener('click', (e) => changeTool(e, "wordTool"));
			editTool.addEventListener('click', (e) => changeTool(e, "editTool"));
			deleteTool.addEventListener('click', (e) => changeTool(e, "deleteTool"));
			
			const wordCreationForm = document.querySelector("#wordCreationForm");
			const wordContent = document.querySelector("#wordContent");
			wordContent.addEventListener('input', onWordDetailUpdate);
			wordCreationForm.addEventListener('click', onWordDetailUpdate);
			wordCreationForm.addEventListener('input', onWordDetailUpdate);
			wordCreationForm.addEventListener('change', onWordDetailUpdate);
			
			ctx = canvas.getContext('2d');
			
			let image = new Image();
			image.src = "lined-paper-texture-background.jpeg";
			
			image.onload = () => {
				bgImage = image;
			}
			
			requestAnimationFrame(redrawCanvas);
		};
		
		window.onload = init;
	
    </script>
</head>
<body>
	<div id="header" class="bg-primary center-block text-center">
		<h1 class="center-block">Magnetic Poetry w/ Friends</h1>
		<hr>
	</div>
	<div id="mainContainer" class="container">
		<div class="row">
			<div class="col-sm-3">
				<h2 class="text-center">Instructions</h2>
				<hr />
				<div id="instructions">
					<p>If you are logged in via Google Plus, you will have persistent access to your contributions. If you are a guest, your session will expire after 4 hours.</p>
					<h3>Tool Details</h3>
					<p>-Use the playback tool to select a word or section (click and drag) of the poem and have it read out loud by Nicole (Amazon Polly).</p>
					<p>-Use the add tool to add word cards to the board. To customize these word cards, edit the details in the 'Word Details' section, then click somewhere on the board to place your new word.</p>
					<p>-Use the movement tool to move words around the board. Words that you can move will have a blue border. The semi-transparent black area at the bottom of the screen is your local word bank.
					Dragging words from your local word bank to the public space will make them public, and dragging them back into the local space will make them private. You may only move words
					that are part of your local word bank / words that you previously placed.</p>
					<p>-Use the edit tool to edit a single or selection (click and drag) of words. Word attributes such as color, font, and size may be modified, but the core word content may not. As with moving
					you may only edit words that you originally placed / had control over. (Yellow outline when edit tool is selected).</p>
					<p>-Use the delete tool to remove a single word or a selection (click and drag) of words. Words that are deleted will be removed from both the public and local space. One again, you may only
					delete words that you have control over. (Red outline when delete tool is selected).</p>
					<p>Feel free to use the chat on the left panel.</p>
					<p>Most importantly, have fun and get creative!</p>
				</div>
				<h2 class="text-center">Chat Room</h2>
				<hr />
				<div id="chatRoom">
				</div>
				<p>
					<div class="input-group">
						<input id="chatText" type="text" placeholder="Thoughts..." class="form-control" />
						<div class="input-group-btn">
							<button id="sendMessage" class="btn btn-success btn-md">Send</button>
						</div>
					</div>
				</p>
			</div>
			<div id="canvasContainer" class="col-sm-6">
				<canvas width="800" height="800" id="viewport"></canvas>
			</div>
			<div class="col-sm-3">
				<h2 class="text-center">Tool Set</h2>
				<hr />
				<p>
					<button id="playbackTool" class="btn btn-success">
						<span class="glyphicon glyphicon-play-circle"></span> Playback Select Tool
					</button>
				</p>
				<hr />
				<p>
					<button id="addWordTool" class="btn btn-info">
						<span class="glyphicon glyphicon-plus"></span> Word Add Tool
					</button>
				</p>
				<hr />
				<p>
					<button id="wordTool" class="btn btn-info">
						<span class="glyphicon glyphicon-move"></span> Word Movement Tool
					</button>
					<span id="selectedToolMarker">
						<span> - </span>
						<span class="glyphicon glyphicon-ok"></span>
						<span>- Selected Tool</span>
					</span>
				</p>
				<hr />
				<p>
					<button id="editWordTool" class="btn btn-warning">
						<span class="glyphicon glyphicon-pencil"></span> Word Edit Select Tool
					</button>
				</p>
				<hr />
				<p>
					<button id="deleteWordTool" class="btn btn-danger">
						<span class="glyphicon glyphicon-minus"></span> Word Delete Select Tool
					</button>
				</p>
				<hr />
				
				<h2>Word Details</h2>
				<hr />
				
				<form id="wordCreationForm">
					<p>
						<label for="wordContent">Word:</label>
						<input id="wordContent" class="form-control" type="text" name="wordContent" />
					</p>
					<p>
						<div class="sideBySide">
							<label for="bgColorSelect">Background Color: </label>
							<input id="bgColorSelect" name="bgColorSelect" class="form-control" type="color" value="#ADD8E6" />
						</div>
						<div class="sideBySide">
							<label for="textColorSelect">Text Color: </label>
							<input id="textColorSelect" name="textColorSelect" class="form-control" type="color" value="#000000" />
						</div>
					</p>
					<p>
						<label for="fontSelect">Font: </label>
						<select id="fontSelect" name="fontSelect" class="form-control">
							<option value="Arial">Arial</option>
							<option value="Pacifico">Pacifico</option>
							<option value="Indie Flower">Indie Flower</option>
							<option value="Kaushan Script">Kaushan Script</option>
							<option value="Gloria Hallelujah">Gloria Hallelujah</option>
							<option selected="selected" value="Nanum Pen Script">Nanum Pen Script</option>
							<option value="Amatic SC">Amatic SC</option>
							<option value="Berkshire Swash">Berkshire Swash</option>
							<option value="Permanent Marker">Permanent Marker</option>
							<option value="Tangerine">Tangerine</option>
						</select>
					</p>
					<p>
						<label for="fontSizeSelect">Font Size: </label>
						<select id="fontSizeSelect" name="fontSizeSelect" class="form-control">
							<option value="10">10px</option>
							<option value="12">12px</option>
							<option value="16">16px</option>
							<option value="24">24px</option>
							<option selected="selected" value="32">32px</option>
							<option value="48">48px</option>
							<option value="72">72px</option>
							<option value="96">96px</option>
						</select>
					</p>
				</form>
			</div>
		</div>
	</div>
</body>
</html>